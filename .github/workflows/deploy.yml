# Auto-generated by AutoRollback Tool for AKS
# Generated on: 2026-02-25T13:02:57.887022Z

name: Deploy to AKS

on:
  # NOTE: push trigger is disabled for initial setup
  # After first successful deployment, uncomment to enable auto-deploy on push
  # push:
  #   branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'Dev'

env:
  ACR_LOGIN_SERVER: testappdevacrp3rcyy.azurecr.io
  ACR_NAME: testappdevacrp3rcyy
  AKS_CLUSTER_NAME: Alpha-cluster
  RESOURCE_GROUP: AlphaRG
  IMAGE_NAME: my-test-app
  K8S_NAMESPACE: default

jobs:
  build-and-deploy:
    name: Build Docker Image and Deploy to AKS
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and tag Docker image
        run: |
          echo "üê≥ Building Docker image..."
          IMAGE_TAG=${{ github.sha }}
          docker build -t $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG -f ./Dockerfile .
          docker tag $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG $ACR_LOGIN_SERVER/$IMAGE_NAME:latest
          echo "‚úÖ Image built: $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Push image to ACR
        run: |
          echo "üì§ Pushing image to ACR..."
          docker push $ACR_LOGIN_SERVER/$IMAGE_NAME:${{ env.IMAGE_TAG }}
          docker push $ACR_LOGIN_SERVER/$IMAGE_NAME:latest
          echo "‚úÖ Image pushed successfully"

      - name: Set up kubectl with kubeconfig
        run: |
          echo "üéØ Setting up kubectl with kubeconfig..."
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl config current-context
          echo "‚úÖ Connected to cluster: $AKS_CLUSTER_NAME"

      - name: Deploy Kubernetes manifests
        run: |
          echo "üì¶ Deploying to AKS..."
          kubectl apply -f k8s/deployment.yml --namespace=$K8S_NAMESPACE
          echo "‚úÖ Manifests applied"

      - name: Update deployment image
        run: |
          echo "üîÑ Updating deployment with new image..."
          kubectl set image deployment/my-test-app my-test-app=$ACR_LOGIN_SERVER/$IMAGE_NAME:${{ env.IMAGE_TAG }} --namespace=$K8S_NAMESPACE
          echo "‚úÖ Image updated"

      - name: Wait for rollout to complete
        id: rollout
        run: |
          echo "‚è≥ Waiting for deployment rollout..."
          echo "Timeout: 10 minutes"

          # Try rollout status with longer timeout
          if kubectl rollout status deployment/my-test-app --namespace=$K8S_NAMESPACE --timeout=10m; then
            echo "‚úÖ Deployment completed successfully"
            echo "rollout_success=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Rollout did not complete within timeout"
            echo "rollout_success=false" >> $GITHUB_OUTPUT

            echo ""
            echo "üìã Diagnosing rollout issue..."
            echo "================================"

            echo ""
            echo "üì¶ Pod Status:"
            kubectl get pods --namespace=$K8S_NAMESPACE -l app=my-test-app -o wide

            echo ""
            echo "üìù Recent Pod Events:"
            kubectl get events --namespace=$K8S_NAMESPACE --sort-by='.lastTimestamp' | grep -i "my-test-app" | tail -20 || echo "No events found"

            echo ""
            echo "üîç Pod Descriptions (for failing pods):"
            for pod in $(kubectl get pods --namespace=$K8S_NAMESPACE -l app=my-test-app --field-selector=status.phase!=Running -o jsonpath='{{.items[*].metadata.name}}'); do
              echo "--- Pod: $pod ---"
              kubectl describe pod $pod --namespace=$K8S_NAMESPACE | tail -30
            done

            echo ""
            echo "üìä Node Resources:"
            kubectl top nodes 2>/dev/null || echo "Metrics server not available"

            # Don't fail the job yet - let diagnostics run
            exit 1
          fi

      - name: Verify deployment
        if: steps.rollout.outputs.rollout_success == 'true'
        run: |
          echo "üîç Verifying deployment..."
          kubectl get pods --namespace=$K8S_NAMESPACE -l app=my-test-app
          kubectl get service my-test-app --namespace=$K8S_NAMESPACE

      - name: Rollout failure diagnostics
        if: failure() && steps.rollout.outputs.rollout_success == 'false'
        run: |
          echo "‚ùå DEPLOYMENT ROLLOUT FAILED"
          echo "============================"
          echo ""
          echo "Common causes:"
          echo "1. Insufficient cluster resources (CPU/Memory)"
          echo "2. Image pull errors (check ACR credentials)"
          echo "3. Liveness/Readiness probe failures"
          echo "4. Application crash on startup"
          echo ""
          echo "üîß Troubleshooting steps:"
          echo "1. Check pod logs: kubectl logs -l app=my-test-app --namespace=$K8S_NAMESPACE"
          echo "2. Describe pods: kubectl describe pods -l app=my-test-app --namespace=$K8S_NAMESPACE"
          echo "3. Check node capacity: kubectl describe nodes | grep -A5 'Allocated resources'"
          echo ""
          echo "üìù Recent container logs (if available):"
          kubectl logs -l app=my-test-app --namespace=$K8S_NAMESPACE --tail=50 2>/dev/null || echo "No logs available yet"

      - name: Get Service URL
        run: |
          echo "üåê Getting service endpoint..."
          kubectl get service my-test-app --namespace=$K8S_NAMESPACE -o jsonpath='{{.status.loadBalancer.ingress[0].ip}}'
          echo ""
          echo "‚ÑπÔ∏è  Note: LoadBalancer IP may take a few minutes to be assigned"

      - name: Health check (optional)
        continue-on-error: true
        run: |
          echo "üè• Running health check..."
          # Wait for LoadBalancer IP
          sleep 30
          SERVICE_IP=$(kubectl get service my-test-app --namespace=$K8S_NAMESPACE -o jsonpath='{{.status.loadBalancer.ingress[0].ip}}')
          if [ -n "$SERVICE_IP" ]; then
            curl -f http://$SERVICE_IP/health || echo "‚ö†Ô∏è  Health check endpoint not ready yet"
          else
            echo "‚ö†Ô∏è  LoadBalancer IP not assigned yet"
          fi

      - name: Deployment Summary
        if: always()
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo "Image: $ACR_LOGIN_SERVER/$IMAGE_NAME:${{ env.IMAGE_TAG }}"
          echo "Cluster: $AKS_CLUSTER_NAME"
          echo "Namespace: $K8S_NAMESPACE"
          echo "Deployment: my-test-app"
