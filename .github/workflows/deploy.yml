# Auto-generated by AutoRollback Tool
# Generated on: 2025-11-20T10:08:24.593659Z

name: Deploy to Azure

on:
  # NOTE: push trigger is disabled for initial setup to avoid using stale secrets
  # After first successful deployment, you can uncomment this to enable auto-deploy on push
  # push:
  #   branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'Production'

env:
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  
jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build application
        run: npm run build

      
      # Tests skipped (runTests=false)
      
      - name: Determine build output directory
        id: build-path
        run: |
          # Check for common build output directories
          if [ -d "./build" ]; then
            echo "path=./build" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./build"
          elif [ -d "./dist" ]; then
            echo "path=./dist" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./dist"
          elif [ -d "./target" ]; then
            echo "path=./target" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./target"
          elif [ -d "./publish" ]; then
            echo "path=./publish" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./publish"
          elif [ -d "./build/libs" ]; then
            echo "path=./build/libs" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./build/libs"
          else
            echo "âŒ No build output directory found!"
            echo "Checked: ./build, ./dist, ./target, ./publish, ./build/libs"
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: ${{ steps.build-path.outputs.path }}
          retention-days: 1

  deploy:
    name: Deploy to Azure
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: ./artifact

      - name: Create deployment package
        run: |
          cd artifact

          # Show what files we're about to deploy
          echo "ðŸ“‹ Files in artifact directory:"
          ls -lah
          echo ""

          # Check if this is a static site (has index.html but no server files)
          if [ -f "index.html" ] && [ ! -f "server.js" ] && [ ! -f "index.js" ] && [ ! -f "app.js" ]; then
            echo "ðŸ“¦ Detected static site - creating package.json for Node.js runtime"

            # Create a minimal package.json for static site serving using echo to avoid YAML parsing issues
            echo '{' > package.json
            echo '  "name": "static-app",' >> package.json
            echo '  "version": "1.0.0",' >> package.json
            echo '  "scripts": {' >> package.json
            echo '    "start": "npx -y serve@latest -s . -l ${PORT:-8080}"' >> package.json
            echo '  },' >> package.json
            echo '  "engines": {' >> package.json
            echo '    "node": ">=18.0.0"' >> package.json
            echo '  }' >> package.json
            echo '}' >> package.json

            echo "âœ… Created package.json with serve command"
            echo "âœ… App will be served using: npx serve -s . -l $PORT"
          fi

          # List files before zipping to confirm package.json was created
          echo ""
          echo "ðŸ“‹ Files that will be deployed:"
          ls -lah

          zip -r ../deploy.zip .
          cd ..
          echo "ðŸ“¦ Deployment package created: $(du -h deploy.zip)"

      - name: Deploy to Azure App Service via Kudu API
        run: |
          echo "ðŸš€ Deploying to conversational-simulation-ai-app-o3uj78..."

          # Extract credentials directly in this step to avoid variable expansion issues
          PUBLISH_PROFILE='${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}'

          # Show publish profile structure (first 300 chars, no secrets)
          echo "ðŸ“‹ Publish profile structure:"
          echo "$PUBLISH_PROFILE" | head -c 300
          echo ""
          echo "..."

          # Extract userName and userPWD from XML
          USERNAME=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*userName="\([^"]*\)".*/\1/p' | head -1)
          PASSWORD=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*userPWD="\([^"]*\)".*/\1/p' | head -1)

          # Also extract publishUrl to verify we have the right profile
          PUBLISH_URL=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*publishUrl="\([^"]*\)".*/\1/p' | head -1)

          # Verify extraction
          if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
            echo "âŒ Failed to extract credentials from publish profile"
            echo "Publish profile may be malformed"
            exit 1
          fi

          # Mask password in logs
          echo "::add-mask::$PASSWORD"
          echo "âœ… Credentials extracted successfully"
          echo "ðŸ“ Publish URL from profile: $PUBLISH_URL"
          echo "ðŸŽ¯ Expected app: conversational-simulation-ai-app-o3uj78"

          # Validate that we're deploying to the right app
          # For staging slots, the publish URL will contain "app-name-staging" or "app-name__staging"
          EXPECTED_IN_URL="conversational-simulation-ai-app-o3uj78-staging"
          if [[ ! "$PUBLISH_URL" =~ "$EXPECTED_IN_URL" ]]; then
            echo "âš ï¸âš ï¸âš ï¸  WARNING: Publish profile mismatch!"
            echo "Expected URL to contain: $EXPECTED_IN_URL"
            echo "But publishUrl is: $PUBLISH_URL"
            echo "This will cause 401 authentication errors"
            echo ""
            echo "The publish profile credentials are for a different App Service!"
            exit 1
          fi

          echo "âœ… Publish profile validation passed (URL contains $EXPECTED_IN_URL)"

          # Use Kudu ZipDeploy API - using /api/zip/site/wwwroot for reliable extraction
          # This endpoint directly extracts the zip to wwwroot (more reliable than /api/zipdeploy)
          KUDU_URL="https://conversational-simulation-ai-app-o3uj78-staging.scm.azurewebsites.net/api/zip/site/wwwroot"
          echo "ðŸ“ Deploying to: $KUDU_URL"
          echo "ðŸ”µ Deployment target: Staging slot (blue/green deployment)"
          echo "ðŸŽ¯ Staging slot URL: https://conversational-simulation-ai-app-o3uj78-staging.azurewebsites.net"

          # Deploy using basic auth from publish profile
          # Using PUT /api/zip/site/wwwroot to directly extract to wwwroot
          echo "â³ Starting deployment (this may take 1-2 minutes)..."
          HTTP_CODE=$(curl -X PUT \
            -u "$USERNAME:$PASSWORD" \
            --data-binary @deploy.zip \
            -H "Content-Type: application/zip" \
            -H "Cache-Control: no-cache" \
            --max-time 300 \
            -w "%{http_code}" \
            -o /tmp/deploy_response.txt \
            "$KUDU_URL")

          echo "HTTP Status Code: $HTTP_CODE"
          echo "Response:"
          cat /tmp/deploy_response.txt || echo "(No response body)"

          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
            echo "âœ… Deployment API call successful! Status: $HTTP_CODE"

            # Wait a bit for deployment to stabilize
            echo "â³ Waiting 20 seconds for deployment to stabilize..."
            sleep 20

            # Verify files were actually deployed by checking wwwroot
            # Check the deployment target (staging or production)
            echo "ðŸ” Verifying deployment..."
            VERIFY_URL="https://conversational-simulation-ai-app-o3uj78-staging.scm.azurewebsites.net/api/vfs/site/wwwroot/"
            echo "Checking: $VERIFY_URL"

            WWWROOT_CHECK=$(curl -u "$USERNAME:$PASSWORD" \
              -s \
              "$VERIFY_URL")

            echo "ðŸ“‹ Files in wwwroot:"
            echo "$WWWROOT_CHECK" | head -c 1000

            if [[ "$WWWROOT_CHECK" == *"index.html"* ]] || [[ "$WWWROOT_CHECK" == *""name":"* ]]; then
              echo "âœ… Verified: Files deployed successfully to wwwroot"

              # Restart the app to pick up the new files
              echo "ðŸ”„ Restarting app to load new deployment..."
              RESTART_URL="https://conversational-simulation-ai-app-o3uj78-staging.scm.azurewebsites.net/api/app/restart"
              RESTART_CODE=$(curl -X POST \
                -u "$USERNAME:$PASSWORD" \
                -s -o /dev/null -w "%{http_code}" \
                "$RESTART_URL")

              if [ "$RESTART_CODE" -eq 200 ]; then
                echo "âœ… App restarted successfully"
              else
                echo "âš ï¸  Restart returned status: $RESTART_CODE (app may still work)"
              fi

              echo "ðŸŽ‰ Application deployed to staging slot: https://conversational-simulation-ai-app-o3uj78-staging.azurewebsites.net"
              echo "â­ï¸  Next: Health check will verify the staging slot before swapping to production"
            else
              echo "âš ï¸âš ï¸âš ï¸  WARNING: Files NOT found in wwwroot!"
              echo "This usually means the deployment didn't extract properly."
              echo ""
              echo "Checking if hostingstart.html exists (default Azure placeholder):"
              HOSTINGSTART_CHECK=$(curl -u "$USERNAME:$PASSWORD" -s "$VERIFY_URL" | grep -i hostingstart || echo "not found")
              echo "$HOSTINGSTART_CHECK"
              echo ""

              echo "Trying to list individual files:"
              curl -u "$USERNAME:$PASSWORD" -s "${VERIFY_URL}index.html" | head -c 200 || echo "index.html not found"
              echo ""

              echo "âŒ Deployment verification failed!"
              echo "The zip was uploaded but files were not extracted to wwwroot."
              exit 1
            fi
          else
            echo "âŒ Deployment failed with status: $HTTP_CODE"
            echo "Response body:"
            cat /tmp/deploy_response.txt

            if [ "$HTTP_CODE" -eq 401 ]; then
              echo ""
              echo "âŒ Authentication failed (401 Unauthorized)"
              echo ""
              echo "Possible causes:"
              echo "1. Basic authentication not enabled on App Service"
              echo "2. Publish profile credentials expired or rotated"
              echo "3. Username/password extraction failed from XML"
              echo ""
              echo "Testing Kudu API accessibility..."
              KUDU_ROOT_CODE=$(curl -u "$USERNAME:$PASSWORD" -s -o /dev/null -w "%{http_code}" "https://conversational-simulation-ai-app-o3uj78.scm.azurewebsites.net/")
              echo "Kudu root status: $KUDU_ROOT_CODE"

            elif [ "$HTTP_CODE" -eq 403 ]; then
              echo ""
              echo "âŒ Authorization failed (403 Forbidden)"
              echo ""
              echo "Credentials are valid but deployment is not allowed. Possible causes:"
              echo "1. The deployment user doesn't have deployment permissions"
              echo "2. The App Service has deployment restrictions/locks"
              echo "3. The zip file format is incorrect or corrupted"
              echo ""
              echo "Checking zip file integrity..."
              if [ -f deploy.zip ]; then
                echo "Zip file size: $(ls -lh deploy.zip | awk '{print $5}')"
                echo "Zip file contents:"
                unzip -l deploy.zip | head -20
              fi
              echo ""
              echo "Testing Kudu API root access..."
              KUDU_ROOT_CODE=$(curl -u "$USERNAME:$PASSWORD" -s -o /dev/null -w "%{http_code}" "https://conversational-simulation-ai-app-o3uj78.scm.azurewebsites.net/")
              echo "Kudu root status: $KUDU_ROOT_CODE"

              if [ "$KUDU_ROOT_CODE" -eq 200 ]; then
                echo "âœ… Kudu API is accessible - the issue is specific to deployment"
                echo ""
                echo "Trying alternative deployment method (wwwroot)..."
                WWWROOT_CODE=$(curl -X PUT \
                  -u "$USERNAME:$PASSWORD" \
                  --data-binary @deploy.zip \
                  -H "Content-Type: application/zip" \
                  -s -o /dev/null -w "%{http_code}" \
                  "https://conversational-simulation-ai-app-o3uj78.scm.azurewebsites.net/api/zip/site/wwwroot")

                echo "Alternative deployment status: $WWWROOT_CODE"

                if [ "$WWWROOT_CODE" -eq 200 ] || [ "$WWWROOT_CODE" -eq 201 ]; then
                  echo "âœ… Deployment successful via alternative method!"
                  echo "ðŸŽ‰ Application deployed to https://conversational-simulation-ai-app-o3uj78.azurewebsites.net"
                  exit 0
                fi
              fi
            fi
            exit 1
          fi

      

      - name: Pre-Swap Validation (Staging Slot)
        id: pre-swap-validation
        continue-on-error: true
        run: |
          echo "ðŸŽ¯ PRODUCTION DEPLOYMENT - High Ceremony Path"
          echo "Step 1: Pre-swap validation of staging slot"
          echo ""
          echo "â³ Waiting 30 seconds for staging slot to start..."
          sleep 30

          echo "ðŸ” Performing pre-swap health check on staging slot..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          HEALTH_PASSED=false

          STAGING_URL="https://conversational-simulation-ai-app-o3uj78-staging.azurewebsites.net/"
          echo "Staging slot URL: $STAGING_URL"

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL" || echo "000")

            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "304" ]; then
              echo "âœ… Pre-swap validation passed! Staging slot is healthy (HTTP $HTTP_STATUS)."
              HEALTH_PASSED=true
              break
            fi

            echo "âš ï¸  Health check failed (HTTP $HTTP_STATUS). Retry $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ "$HEALTH_PASSED" = "false" ]; then
            echo "âŒ Pre-swap validation failed after $MAX_RETRIES attempts!"
            echo "âŒ Staging slot is not healthy - ABORTING deployment to production"
            echo "health_failed=true" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "âœ… Staging slot validated - ready to swap to production"
            echo "health_failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Swap Staging to Production
        id: swap-to-production
        if: steps.pre-swap-validation.outputs.health_failed == 'false'
        run: |
          echo "Step 2: Swapping staging slot to production"
          echo "ðŸ”„ Performing slot swap: staging â†’ production"
          echo ""

          AZURE_TOKEN="${{ secrets.AZURE_ACCESS_TOKEN }}"
          SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          RESOURCE_GROUP="${{ secrets.AZURE_RESOURCE_GROUP }}"

          echo "::add-mask::$AZURE_TOKEN"

          SWAP_URL="https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Web/sites/conversational-simulation-ai-app-o3uj78/slots/staging/slotsswap?api-version=2023-01-01"

          echo "â³ Initiating slot swap (takes 5-15 seconds)..."

          SWAP_STATUS=$(curl -X POST \
            -H "Authorization: Bearer $AZURE_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"targetSlot": "production"}' \
            -s -o /tmp/swap_response.txt \
            -w "%{http_code}" \
            "$SWAP_URL")

          echo "Swap HTTP Status: $SWAP_STATUS"

          if [ "$SWAP_STATUS" -eq 200 ] || [ "$SWAP_STATUS" -eq 202 ]; then
            echo "âœ… Slot swap initiated successfully!"
            echo "â³ Waiting 15 seconds for swap to complete..."
            sleep 15
            echo "âœ… Slot swap completed!"
            echo "ðŸŽ‰ New version is now in production"
            echo "ðŸ“¦ Old version is now in staging slot (instant rollback available)"
            echo "swap_succeeded=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Slot swap failed with status: $SWAP_STATUS"
            cat /tmp/swap_response.txt || echo "(No response)"
            echo "swap_succeeded=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Post-Swap Validation with Auto-Rollback (5-Minute Monitoring)
        id: post-swap-validation
        if: steps.swap-to-production.outputs.swap_succeeded == 'true'
        run: |
          echo "Step 3: Post-swap validation with auto-rollback capability"
          echo "ðŸ” Monitoring production for 5 minutes with health checks every 30 seconds"
          echo ""

          PROD_URL="https://conversational-simulation-ai-app-o3uj78.azurewebsites.net/"
          echo "Production URL: $PROD_URL"

          MONITORING_DURATION=300  # 5 minutes
          CHECK_INTERVAL=30        # 30 seconds
          ELAPSED_TIME=0
          FAILED_CHECKS=0
          MAX_FAILED_CHECKS=2      # Allow 2 failures before triggering rollback

          echo "â³ Starting 5-minute monitoring window..."
          echo ""

          while [ $ELAPSED_TIME -lt $MONITORING_DURATION ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL" || echo "000")

            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "304" ]; then
              echo "âœ… [$ELAPSED_TIME/$MONITORING_DURATION seconds] Health check passed (HTTP $HTTP_STATUS)"
              FAILED_CHECKS=0  # Reset failure counter on success
            else
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
              echo "âš ï¸  [$ELAPSED_TIME/$MONITORING_DURATION seconds] Health check failed (HTTP $HTTP_STATUS) - Failure $FAILED_CHECKS/$MAX_FAILED_CHECKS"

              if [ $FAILED_CHECKS -ge $MAX_FAILED_CHECKS ]; then
                echo ""
                echo "âŒâŒâŒ CRITICAL: Production health check failed $FAILED_CHECKS times!"
                echo "âŒ Triggering automatic rollback..."
                echo ""

                # IMPORTANT: Wait for initial swap to complete before attempting rollback
                # Azure may still be processing the initial swap, causing 409 Conflict
                echo "â³ Waiting 30 seconds for Azure to complete any in-progress operations..."
                sleep 30

                # Perform automatic rollback by swapping back
                AZURE_TOKEN="${{ secrets.AZURE_ACCESS_TOKEN }}"
                SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
                RESOURCE_GROUP="${{ secrets.AZURE_RESOURCE_GROUP }}"

                echo "::add-mask::$AZURE_TOKEN"

                ROLLBACK_URL="https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Web/sites/conversational-simulation-ai-app-o3uj78/slots/staging/slotsswap?api-version=2023-01-01"

                echo "ðŸ”„ Performing rollback swap: staging â†’ production (reverting to old version)"

                # Retry rollback if Azure returns 409 Conflict
                MAX_ROLLBACK_RETRIES=3
                ROLLBACK_RETRY=0
                ROLLBACK_SUCCEEDED=false

                while [ $ROLLBACK_RETRY -lt $MAX_ROLLBACK_RETRIES ]; do
                  ROLLBACK_STATUS=$(curl -X POST \
                    -H "Authorization: Bearer $AZURE_TOKEN" \
                    -H "Content-Type: application/json" \
                    -d '{"targetSlot": "production"}' \
                    -s -o /tmp/rollback_response.txt \
                    -w "%{http_code}" \
                    "$ROLLBACK_URL")

                  echo "Rollback HTTP Status: $ROLLBACK_STATUS"

                  if [ "$ROLLBACK_STATUS" -eq 200 ] || [ "$ROLLBACK_STATUS" -eq 202 ]; then
                    echo "âœ… Automatic rollback successful!"
                    echo "â³ Waiting 15 seconds for rollback to complete..."
                    sleep 15
                    echo "âœ… Production has been restored to previous version"
                    echo "âŒ Deployment FAILED and was automatically rolled back"
                    ROLLBACK_SUCCEEDED=true
                    break
                  elif [ "$ROLLBACK_STATUS" -eq 409 ]; then
                    ROLLBACK_RETRY=$((ROLLBACK_RETRY + 1))
                    if [ $ROLLBACK_RETRY -lt $MAX_ROLLBACK_RETRIES ]; then
                      echo "âš ï¸  Rollback failed with 409 Conflict (Azure still processing previous operation)"
                      echo "Retry $ROLLBACK_RETRY/$MAX_ROLLBACK_RETRIES: Waiting 30 seconds before retry..."
                      sleep 30
                    else
                      echo "âŒ Rollback failed after $MAX_ROLLBACK_RETRIES attempts (409 Conflict)"
                      break
                    fi
                  else
                    echo "âŒ Automatic rollback FAILED with status: $ROLLBACK_STATUS"
                    cat /tmp/rollback_response.txt || echo "(No response)"
                    break
                  fi
                done

                if [ "$ROLLBACK_SUCCEEDED" = "false" ]; then
                  echo "âš ï¸âš ï¸âš ï¸  MANUAL INTERVENTION REQUIRED!"
                  echo "Please manually swap slots in Azure Portal to restore service"
                  echo "Azure Portal: https://portal.azure.com â†’ conversational-simulation-ai-app-o3uj78 â†’ Deployment slots â†’ Swap"
                fi

                echo "health_failed=true" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi

            sleep $CHECK_INTERVAL
            ELAPSED_TIME=$((ELAPSED_TIME + CHECK_INTERVAL))
          done

          echo ""
          echo "âœ…âœ…âœ… POST-SWAP VALIDATION SUCCESSFUL!"
          echo "âœ… Production has been healthy for $MONITORING_DURATION seconds"
          echo "âœ… Deployment completed successfully"
          echo "health_failed=false" >> $GITHUB_OUTPUT

      - name: Check if Rollback is Possible
        id: rollback-check
        if: steps.health-check.outputs.health_failed == 'true'
        run: |
          echo "ðŸ” Checking if rollback is possible..."

          # Check if this is the first deployment (no previous deployment slot)
          # For Azure App Service, check if there are previous deployments
          DEPLOYMENT_COUNT=$(az webapp deployment list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name conversational-simulation-ai-app-o3uj78 \
            --query "length(@)" \
            --output tsv 2>/dev/null || echo "0")

          if [ "$DEPLOYMENT_COUNT" -le "1" ]; then
            echo "âš ï¸  This appears to be the first deployment - no previous version to rollback to"
            echo "rollback_possible=false" >> $GITHUB_OUTPUT
            echo "::warning::Health check failed on first deployment. No rollback performed."
            exit 0
          else
            echo "âœ… Previous deployment found - rollback is possible"
            echo "rollback_possible=true" >> $GITHUB_OUTPUT
          fi

      - name: Trigger Rollback on Failure
        if: steps.rollback-check.outputs.rollback_possible == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            console.log('ðŸ”„ Triggering automatic rollback...');
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'rollback.yml',
              ref: 'main',
              inputs: {
                reason: 'Deployment health check failed',
                failed_run_id: context.runId.toString()
              }
            });
