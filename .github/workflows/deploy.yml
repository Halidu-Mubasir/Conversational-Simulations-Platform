# Auto-generated by AutoRollback Tool
# Generated on: 2025-11-13T15:02:43.630404Z

name: Deploy to Azure

on:
  # NOTE: push trigger is disabled for initial setup to avoid using stale secrets
  # After first successful deployment, you can uncomment this to enable auto-deploy on push
  # push:
  #   branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'Dev'

env:
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  
jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build application
        run: npm run build

      
      # Tests skipped (runTests=false)
      
      - name: Determine build output directory
        id: build-path
        run: |
          # Check for common build output directories
          if [ -d "./build" ]; then
            echo "path=./build" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./build"
          elif [ -d "./dist" ]; then
            echo "path=./dist" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./dist"
          elif [ -d "./target" ]; then
            echo "path=./target" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./target"
          elif [ -d "./publish" ]; then
            echo "path=./publish" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./publish"
          elif [ -d "./build/libs" ]; then
            echo "path=./build/libs" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./build/libs"
          else
            echo "âŒ No build output directory found!"
            echo "Checked: ./build, ./dist, ./target, ./publish, ./build/libs"
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: ${{ steps.build-path.outputs.path }}
          retention-days: 1

  deploy:
    name: Deploy to Azure
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: ./artifact

      - name: Create deployment package
        run: |
          cd artifact

          # Show what files we're about to deploy
          echo "ðŸ“‹ Files in artifact directory:"
          ls -lah
          echo ""

          # Check if this is a static site (has index.html but no server files)
          if [ -f "index.html" ] && [ ! -f "server.js" ] && [ ! -f "index.js" ] && [ ! -f "app.js" ]; then
            echo "ðŸ“¦ Detected static site - creating package.json for Node.js runtime"

            # Create a minimal package.json for static site serving using echo to avoid YAML parsing issues
            echo '{' > package.json
            echo '  "name": "static-app",' >> package.json
            echo '  "version": "1.0.0",' >> package.json
            echo '  "scripts": {' >> package.json
            echo '    "start": "npx -y serve@latest -s . -l ${PORT:-8080}"' >> package.json
            echo '  },' >> package.json
            echo '  "engines": {' >> package.json
            echo '    "node": ">=18.0.0"' >> package.json
            echo '  }' >> package.json
            echo '}' >> package.json

            echo "âœ… Created package.json with serve command"
            echo "âœ… App will be served using: npx serve -s . -l $PORT"
          fi

          # List files before zipping to confirm package.json was created
          echo ""
          echo "ðŸ“‹ Files that will be deployed:"
          ls -lah

          zip -r ../deploy.zip .
          cd ..
          echo "ðŸ“¦ Deployment package created: $(du -h deploy.zip)"

      - name: Deploy to Azure App Service via Kudu API
        run: |
          echo "ðŸš€ Deploying to product-portal-ox3r5t..."

          # Extract credentials directly in this step to avoid variable expansion issues
          PUBLISH_PROFILE='${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}'

          # Show publish profile structure (first 300 chars, no secrets)
          echo "ðŸ“‹ Publish profile structure:"
          echo "$PUBLISH_PROFILE" | head -c 300
          echo ""
          echo "..."

          # Extract userName and userPWD from XML
          USERNAME=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*userName="\([^"]*\)".*/\1/p' | head -1)
          PASSWORD=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*userPWD="\([^"]*\)".*/\1/p' | head -1)

          # Also extract publishUrl to verify we have the right profile
          PUBLISH_URL=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*publishUrl="\([^"]*\)".*/\1/p' | head -1)

          # Verify extraction
          if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
            echo "âŒ Failed to extract credentials from publish profile"
            echo "Publish profile may be malformed"
            exit 1
          fi

          # Mask password in logs
          echo "::add-mask::$PASSWORD"
          echo "âœ… Credentials extracted successfully"
          echo "ðŸ“ Publish URL from profile: $PUBLISH_URL"
          echo "ðŸŽ¯ Expected app: product-portal-ox3r5t"

          # Validate that we're deploying to the right app
          # For staging slots, the publish URL will contain "app-name-staging" or "app-name__staging"
          EXPECTED_IN_URL="product-portal-ox3r5t-dev"
          if [[ ! "$PUBLISH_URL" =~ "$EXPECTED_IN_URL" ]]; then
            echo "âš ï¸âš ï¸âš ï¸  WARNING: Publish profile mismatch!"
            echo "Expected URL to contain: $EXPECTED_IN_URL"
            echo "But publishUrl is: $PUBLISH_URL"
            echo "This will cause 401 authentication errors"
            echo ""
            echo "The publish profile credentials are for a different App Service!"
            exit 1
          fi

          echo "âœ… Publish profile validation passed (URL contains $EXPECTED_IN_URL)"

          # Use Kudu ZipDeploy API - using /api/zip/site/wwwroot for reliable extraction
          # This endpoint directly extracts the zip to wwwroot (more reliable than /api/zipdeploy)
          KUDU_URL="https://product-portal-ox3r5t-dev.scm.azurewebsites.net/api/zip/site/wwwroot"
          echo "ðŸ“ Deploying to: $KUDU_URL"
          echo "ðŸ”µ Deployment target: Staging slot (blue/green deployment)"
          echo "ðŸŽ¯ Staging slot URL: https://product-portal-ox3r5t-dev.azurewebsites.net"

          # Deploy using basic auth from publish profile
          # Using PUT /api/zip/site/wwwroot to directly extract to wwwroot
          echo "â³ Starting deployment (this may take 1-2 minutes)..."
          HTTP_CODE=$(curl -X PUT \
            -u "$USERNAME:$PASSWORD" \
            --data-binary @deploy.zip \
            -H "Content-Type: application/zip" \
            -H "Cache-Control: no-cache" \
            --max-time 300 \
            -w "%{http_code}" \
            -o /tmp/deploy_response.txt \
            "$KUDU_URL")

          echo "HTTP Status Code: $HTTP_CODE"
          echo "Response:"
          cat /tmp/deploy_response.txt || echo "(No response body)"

          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
            echo "âœ… Deployment API call successful! Status: $HTTP_CODE"

            # Wait a bit for deployment to stabilize
            echo "â³ Waiting 20 seconds for deployment to stabilize..."
            sleep 20

            # Verify files were actually deployed by checking wwwroot
            # Check the deployment target (staging or production)
            echo "ðŸ” Verifying deployment..."
            VERIFY_URL="https://product-portal-ox3r5t-dev.scm.azurewebsites.net/api/vfs/site/wwwroot/"
            echo "Checking: $VERIFY_URL"

            WWWROOT_CHECK=$(curl -u "$USERNAME:$PASSWORD" \
              -s \
              "$VERIFY_URL")

            echo "ðŸ“‹ Files in wwwroot:"
            echo "$WWWROOT_CHECK" | head -c 1000

            if [[ "$WWWROOT_CHECK" == *"index.html"* ]] || [[ "$WWWROOT_CHECK" == *""name":"* ]]; then
              echo "âœ… Verified: Files deployed successfully to wwwroot"

              # Restart the app to pick up the new files
              echo "ðŸ”„ Restarting app to load new deployment..."
              RESTART_URL="https://product-portal-ox3r5t-dev.scm.azurewebsites.net/api/app/restart"
              RESTART_CODE=$(curl -X POST \
                -u "$USERNAME:$PASSWORD" \
                -s -o /dev/null -w "%{http_code}" \
                "$RESTART_URL")

              if [ "$RESTART_CODE" -eq 200 ]; then
                echo "âœ… App restarted successfully"
              else
                echo "âš ï¸  Restart returned status: $RESTART_CODE (app may still work)"
              fi

              echo "ðŸŽ‰ Application deployed to staging slot: https://product-portal-ox3r5t-dev.azurewebsites.net"
              echo "â­ï¸  Next: Health check will verify the staging slot before swapping to production"
            else
              echo "âš ï¸âš ï¸âš ï¸  WARNING: Files NOT found in wwwroot!"
              echo "This usually means the deployment didn't extract properly."
              echo ""
              echo "Checking if hostingstart.html exists (default Azure placeholder):"
              HOSTINGSTART_CHECK=$(curl -u "$USERNAME:$PASSWORD" -s "$VERIFY_URL" | grep -i hostingstart || echo "not found")
              echo "$HOSTINGSTART_CHECK"
              echo ""

              echo "Trying to list individual files:"
              curl -u "$USERNAME:$PASSWORD" -s "${VERIFY_URL}index.html" | head -c 200 || echo "index.html not found"
              echo ""

              echo "âŒ Deployment verification failed!"
              echo "The zip was uploaded but files were not extracted to wwwroot."
              exit 1
            fi
          else
            echo "âŒ Deployment failed with status: $HTTP_CODE"
            echo "Response body:"
            cat /tmp/deploy_response.txt

            if [ "$HTTP_CODE" -eq 401 ]; then
              echo ""
              echo "âŒ Authentication failed (401 Unauthorized)"
              echo ""
              echo "Possible causes:"
              echo "1. Basic authentication not enabled on App Service"
              echo "2. Publish profile credentials expired or rotated"
              echo "3. Username/password extraction failed from XML"
              echo ""
              echo "Testing Kudu API accessibility..."
              KUDU_ROOT_CODE=$(curl -u "$USERNAME:$PASSWORD" -s -o /dev/null -w "%{http_code}" "https://product-portal-ox3r5t.scm.azurewebsites.net/")
              echo "Kudu root status: $KUDU_ROOT_CODE"

            elif [ "$HTTP_CODE" -eq 403 ]; then
              echo ""
              echo "âŒ Authorization failed (403 Forbidden)"
              echo ""
              echo "Credentials are valid but deployment is not allowed. Possible causes:"
              echo "1. The deployment user doesn't have deployment permissions"
              echo "2. The App Service has deployment restrictions/locks"
              echo "3. The zip file format is incorrect or corrupted"
              echo ""
              echo "Checking zip file integrity..."
              if [ -f deploy.zip ]; then
                echo "Zip file size: $(ls -lh deploy.zip | awk '{print $5}')"
                echo "Zip file contents:"
                unzip -l deploy.zip | head -20
              fi
              echo ""
              echo "Testing Kudu API root access..."
              KUDU_ROOT_CODE=$(curl -u "$USERNAME:$PASSWORD" -s -o /dev/null -w "%{http_code}" "https://product-portal-ox3r5t.scm.azurewebsites.net/")
              echo "Kudu root status: $KUDU_ROOT_CODE"

              if [ "$KUDU_ROOT_CODE" -eq 200 ]; then
                echo "âœ… Kudu API is accessible - the issue is specific to deployment"
                echo ""
                echo "Trying alternative deployment method (wwwroot)..."
                WWWROOT_CODE=$(curl -X PUT \
                  -u "$USERNAME:$PASSWORD" \
                  --data-binary @deploy.zip \
                  -H "Content-Type: application/zip" \
                  -s -o /dev/null -w "%{http_code}" \
                  "https://product-portal-ox3r5t.scm.azurewebsites.net/api/zip/site/wwwroot")

                echo "Alternative deployment status: $WWWROOT_CODE"

                if [ "$WWWROOT_CODE" -eq 200 ] || [ "$WWWROOT_CODE" -eq 201 ]; then
                  echo "âœ… Deployment successful via alternative method!"
                  echo "ðŸŽ‰ Application deployed to https://product-portal-ox3r5t.azurewebsites.net"
                  exit 0
                fi
              fi
            fi
            exit 1
          fi

      

      - name: Health Check (Dev Slot)
        id: health-check
        continue-on-error: true
        run: |
          echo "ðŸŽ¯ NON-PRODUCTION DEPLOYMENT - Low Ceremony Path"
          echo "Target slot: dev"
          echo "No swapping - deployment complete after health check"
          echo ""
          echo "â³ Waiting 30 seconds for application to start..."
          sleep 30

          echo "ðŸ” Performing health check on dev slot..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          HEALTH_PASSED=false

          HEALTH_CHECK_URL="https://product-portal-ox3r5t-dev.azurewebsites.net/healthz"
          echo "Health check URL: $HEALTH_CHECK_URL"

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL" || echo "000")

            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "304" ]; then
              echo "âœ… Health check passed! Application is healthy (HTTP $HTTP_STATUS)."
              HEALTH_PASSED=true
              break
            fi

            echo "âš ï¸  Health check failed (HTTP $HTTP_STATUS). Retry $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ "$HEALTH_PASSED" = "false" ]; then
            echo "âŒ Health check failed after $MAX_RETRIES attempts!"
            echo "health_failed=true" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "âœ… Deployment to dev slot completed successfully!"
            echo "ðŸŽ‰ Application URL: https://product-portal-ox3r5t-dev.azurewebsites.net"
            echo "health_failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Check if Rollback is Possible
        id: rollback-check
        if: steps.health-check.outputs.health_failed == 'true'
        run: |
          echo "ðŸ” Checking if rollback is possible..."

          # Check if this is the first deployment (no previous deployment slot)
          # For Azure App Service, check if there are previous deployments
          DEPLOYMENT_COUNT=$(az webapp deployment list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name product-portal-ox3r5t \
            --query "length(@)" \
            --output tsv 2>/dev/null || echo "0")

          if [ "$DEPLOYMENT_COUNT" -le "1" ]; then
            echo "âš ï¸  This appears to be the first deployment - no previous version to rollback to"
            echo "rollback_possible=false" >> $GITHUB_OUTPUT
            echo "::warning::Health check failed on first deployment. No rollback performed."
            exit 0
          else
            echo "âœ… Previous deployment found - rollback is possible"
            echo "rollback_possible=true" >> $GITHUB_OUTPUT
          fi

      - name: Trigger Rollback on Failure
        if: steps.rollback-check.outputs.rollback_possible == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            console.log('ðŸ”„ Triggering automatic rollback...');
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'rollback.yml',
              ref: 'main',
              inputs: {
                reason: 'Deployment health check failed',
                failed_run_id: context.runId.toString()
              }
            });
