# Auto-generated by AutoRollback Tool
# Generated on: 2025-11-07T08:02:31.801523Z

name: Deploy to Azure

on:
  # NOTE: push trigger is disabled for initial setup to avoid using stale secrets
  # After first successful deployment, you can uncomment this to enable auto-deploy on push
  # push:
  #   branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'Staging'

env:
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  
jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build application
        run: npm run build

      
      # Tests skipped (runTests=false)
      
      - name: Determine build output directory
        id: build-path
        run: |
          # Check for common build output directories
          if [ -d "./build" ]; then
            echo "path=./build" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./build"
          elif [ -d "./dist" ]; then
            echo "path=./dist" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./dist"
          elif [ -d "./target" ]; then
            echo "path=./target" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./target"
          elif [ -d "./publish" ]; then
            echo "path=./publish" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./publish"
          elif [ -d "./build/libs" ]; then
            echo "path=./build/libs" >> $GITHUB_OUTPUT
            echo "âœ… Found build output in ./build/libs"
          else
            echo "âŒ No build output directory found!"
            echo "Checked: ./build, ./dist, ./target, ./publish, ./build/libs"
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: ${{ steps.build-path.outputs.path }}
          retention-days: 1

  deploy:
    name: Deploy to Azure
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: ./artifact

      - name: Create deployment package
        run: |
          cd artifact

          # Check if this is a static site (has index.html but no server files)
          if [ -f "index.html" ] && [ ! -f "server.js" ] && [ ! -f "index.js" ] && [ ! -f "app.js" ]; then
            echo "ðŸ“¦ Detected static site"
            echo "âœ… Static files will be served using Azure App Service startup command (npx serve)"
            echo "Note: No additional configuration needed - the App Service is pre-configured"
          fi

          zip -r ../deploy.zip .
          cd ..
          echo "ðŸ“¦ Deployment package created: $(du -h deploy.zip)"

      - name: Deploy to Azure App Service via Kudu API
        run: |
          echo "ðŸš€ Deploying to product-portal-ku8gmc..."

          # Extract credentials directly in this step to avoid variable expansion issues
          PUBLISH_PROFILE='${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}'

          # Show publish profile structure (first 300 chars, no secrets)
          echo "ðŸ“‹ Publish profile structure:"
          echo "$PUBLISH_PROFILE" | head -c 300
          echo ""
          echo "..."

          # Extract userName and userPWD from XML
          USERNAME=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*userName="\([^"]*\)".*/\1/p' | head -1)
          PASSWORD=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*userPWD="\([^"]*\)".*/\1/p' | head -1)

          # Also extract publishUrl to verify we have the right profile
          PUBLISH_URL=$(echo "$PUBLISH_PROFILE" | sed -n 's/.*publishUrl="\([^"]*\)".*/\1/p' | head -1)

          # Verify extraction
          if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
            echo "âŒ Failed to extract credentials from publish profile"
            echo "Publish profile may be malformed"
            exit 1
          fi

          # Mask password in logs
          echo "::add-mask::$PASSWORD"
          echo "âœ… Credentials extracted successfully"
          echo "ðŸ“ Publish URL from profile: $PUBLISH_URL"
          echo "ðŸŽ¯ Expected app: product-portal-ku8gmc"

          # Validate that we're deploying to the right app
          if [[ ! "$PUBLISH_URL" =~ "product-portal-ku8gmc" ]]; then
            echo "âš ï¸âš ï¸âš ï¸  WARNING: Publish profile mismatch!"
            echo "Expected URL to contain: product-portal-ku8gmc"
            echo "But publishUrl is: $PUBLISH_URL"
            echo "This will cause 401 authentication errors"
            echo ""
            echo "The publish profile credentials are for a different App Service!"
            exit 1
          fi

          echo "âœ… Publish profile validation passed"

          # Use Kudu ZipDeploy API
          # Deploy to staging slot if supported, otherwise direct to production
          KUDU_URL="https://product-portal-ku8gmc-staging.scm.azurewebsites.net/api/zipdeploy"
          echo "ðŸ“ Deploying to: $KUDU_URL"
          echo "ðŸ”µ Deployment target: Staging slot (blue/green deployment)"

          # Deploy using basic auth from publish profile
          # Use synchronous deployment (no isAsync) to ensure it completes
          echo "â³ Starting deployment (this may take 1-2 minutes)..."
          HTTP_CODE=$(curl -X POST \
            -u "$USERNAME:$PASSWORD" \
            --data-binary @deploy.zip \
            -H "Content-Type: application/octet-stream" \
            -H "Cache-Control: no-cache" \
            --max-time 300 \
            -w "%{http_code}" \
            -o /tmp/deploy_response.txt \
            "$KUDU_URL")

          echo "HTTP Status Code: $HTTP_CODE"
          echo "Response:"
          cat /tmp/deploy_response.txt

          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 202 ] || [ "$HTTP_CODE" -eq 201 ]; then
            echo "âœ… Deployment API call successful! Status: $HTTP_CODE"

            # Wait a bit for deployment to stabilize
            echo "â³ Waiting for deployment to stabilize..."
            sleep 15

            # Verify files were actually deployed by checking wwwroot
            echo "ðŸ” Verifying deployment..."
            WWWROOT_CHECK=$(curl -u "$USERNAME:$PASSWORD" \
              -s \
              "https://product-portal-ku8gmc.scm.azurewebsites.net/api/vfs/site/wwwroot/" | head -c 500)

            if [[ "$WWWROOT_CHECK" == *"index.html"* ]] || [[ "$WWWROOT_CHECK" == *""name":"* ]]; then
              echo "âœ… Verified: Files deployed successfully to wwwroot"
              echo "ðŸŽ‰ Application deployed to https://product-portal-ku8gmc.azurewebsites.net"
            else
              echo "âš ï¸  Warning: wwwroot verification inconclusive"
              echo "Files may not have been extracted. Checking wwwroot contents:"
              curl -u "$USERNAME:$PASSWORD" \
                -s \
                "https://product-portal-ku8gmc.scm.azurewebsites.net/api/vfs/site/wwwroot/" | head -20
              echo ""
              echo "If wwwroot is empty, trying alternative deployment method..."

              # Try alternative method: deploy directly to wwwroot via /api/zip
              WWWROOT_URL="https://product-portal-ku8gmc.scm.azurewebsites.net/api/zip/site/wwwroot"
              echo "ðŸ“ Alternative deployment to: $WWWROOT_URL"

              ALT_HTTP_CODE=$(curl -X PUT \
                -u "$USERNAME:$PASSWORD" \
                --data-binary @deploy.zip \
                -H "Content-Type: application/zip" \
                --max-time 300 \
                -s -o /dev/null -w "%{http_code}" \
                "$WWWROOT_URL")

              if [ "$ALT_HTTP_CODE" -eq 200 ] || [ "$ALT_HTTP_CODE" -eq 201 ]; then
                echo "âœ… Alternative deployment successful! Status: $ALT_HTTP_CODE"
                echo "ðŸŽ‰ Application deployed to https://product-portal-ku8gmc.azurewebsites.net"
              else
                echo "âŒ Alternative deployment also failed: $ALT_HTTP_CODE"
                exit 1
              fi
            fi
          else
            echo "âŒ Deployment failed with status: $HTTP_CODE"
            echo "Response body:"
            cat /tmp/deploy_response.txt

            if [ "$HTTP_CODE" -eq 401 ]; then
              echo ""
              echo "âŒ Authentication failed (401 Unauthorized)"
              echo ""
              echo "Possible causes:"
              echo "1. Basic authentication not enabled on App Service"
              echo "2. Publish profile credentials expired or rotated"
              echo "3. Username/password extraction failed from XML"
              echo ""
              echo "Testing Kudu API accessibility..."
              KUDU_ROOT_CODE=$(curl -u "$USERNAME:$PASSWORD" -s -o /dev/null -w "%{http_code}" "https://product-portal-ku8gmc.scm.azurewebsites.net/")
              echo "Kudu root status: $KUDU_ROOT_CODE"

            elif [ "$HTTP_CODE" -eq 403 ]; then
              echo ""
              echo "âŒ Authorization failed (403 Forbidden)"
              echo ""
              echo "Credentials are valid but deployment is not allowed. Possible causes:"
              echo "1. The deployment user doesn't have deployment permissions"
              echo "2. The App Service has deployment restrictions/locks"
              echo "3. The zip file format is incorrect or corrupted"
              echo ""
              echo "Checking zip file integrity..."
              if [ -f deploy.zip ]; then
                echo "Zip file size: $(ls -lh deploy.zip | awk '{print $5}')"
                echo "Zip file contents:"
                unzip -l deploy.zip | head -20
              fi
              echo ""
              echo "Testing Kudu API root access..."
              KUDU_ROOT_CODE=$(curl -u "$USERNAME:$PASSWORD" -s -o /dev/null -w "%{http_code}" "https://product-portal-ku8gmc.scm.azurewebsites.net/")
              echo "Kudu root status: $KUDU_ROOT_CODE"

              if [ "$KUDU_ROOT_CODE" -eq 200 ]; then
                echo "âœ… Kudu API is accessible - the issue is specific to deployment"
                echo ""
                echo "Trying alternative deployment method (wwwroot)..."
                WWWROOT_CODE=$(curl -X PUT \
                  -u "$USERNAME:$PASSWORD" \
                  --data-binary @deploy.zip \
                  -H "Content-Type: application/zip" \
                  -s -o /dev/null -w "%{http_code}" \
                  "https://product-portal-ku8gmc.scm.azurewebsites.net/api/zip/site/wwwroot")

                echo "Alternative deployment status: $WWWROOT_CODE"

                if [ "$WWWROOT_CODE" -eq 200 ] || [ "$WWWROOT_CODE" -eq 201 ]; then
                  echo "âœ… Deployment successful via alternative method!"
                  echo "ðŸŽ‰ Application deployed to https://product-portal-ku8gmc.azurewebsites.net"
                  exit 0
                fi
              fi
            fi
            exit 1
          fi

      
      - name: Health Check
        id: health-check
        continue-on-error: true
        run: |
          echo "â³ Waiting 30 seconds for application to start..."
          sleep 30

          echo "ðŸ” Performing health check..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          HEALTH_PASSED=false

          # For static sites, check root path (/) instead of /health endpoint
          # Accept 200 (OK) or 304 (Not Modified) as success
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.APP_URL }}/healthz || echo "000")

            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "304" ]; then
              echo "âœ… Health check passed! Application is healthy (HTTP $HTTP_STATUS)."
              HEALTH_PASSED=true
              break
            fi

            echo "âš ï¸  Health check failed (HTTP $HTTP_STATUS). Retry $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ "$HEALTH_PASSED" = "false" ]; then
            echo "âŒ Health check failed after $MAX_RETRIES attempts!"
            echo "health_failed=true" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "health_failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Swap Staging Slot to Production
        if: steps.health-check.outputs.health_failed == 'false'
        run: |
          echo "ðŸ”„ Swapping staging slot to production..."
          echo "This will instantly promote staging to production (zero-downtime)"

          az webapp deployment slot swap \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name product-portal-ku8gmc \
            --slot staging \
            --target-slot production

          echo "âœ… Slot swap completed successfully!"
          echo "Production is now running the new version"
          echo "Staging slot contains the previous version for instant rollback if needed"

      - name: Check if Rollback is Possible
        id: rollback-check
        if: steps.health-check.outputs.health_failed == 'true'
        run: |
          echo "ðŸ” Checking if rollback is possible..."

          # Check if this is the first deployment (no previous deployment slot)
          # For Azure App Service, check if there are previous deployments
          DEPLOYMENT_COUNT=$(az webapp deployment list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name product-portal-ku8gmc \
            --query "length(@)" \
            --output tsv 2>/dev/null || echo "0")

          if [ "$DEPLOYMENT_COUNT" -le "1" ]; then
            echo "âš ï¸  This appears to be the first deployment - no previous version to rollback to"
            echo "rollback_possible=false" >> $GITHUB_OUTPUT
            echo "::warning::Health check failed on first deployment. No rollback performed."
            exit 0
          else
            echo "âœ… Previous deployment found - rollback is possible"
            echo "rollback_possible=true" >> $GITHUB_OUTPUT
          fi

      - name: Trigger Rollback on Failure
        if: steps.rollback-check.outputs.rollback_possible == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            console.log('ðŸ”„ Triggering automatic rollback...');
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'rollback.yml',
              ref: 'main',
              inputs: {
                reason: 'Deployment health check failed',
                failed_run_id: context.runId.toString()
              }
            });
